
### DB 락 - 개념 이해 

다음 상황은 이렇다.

- 서로 다른 세션이 데이터 수정을 하려고 한다.
- 세션1에서 데이터 A를 수정한다. 아직 커밋은 하지 않았다.
- 세션2에서 데이터 A를 다르게 수정한다.

이 상황에서 데이터 A가 수정되면 원자성이 깨지게 된다. 여기에 더해 만약 세션1이 롤백된다면 세션2는 잘못된 데이터를 수정하는 문제까지 발생하게 된다.

이런 문제를 방지하기 위해 락(`lock`)이 존재한다.

컨셉은 간단하다.

1. UPDATE 가 발생하는 시점에서 해당 세션은 해당 레코드에 **락**을 건다.
2. 해당 세션에서 `commit` 혹은 `rollback` 이 일어나기 전까지 다른 세션에서는 해당 레코드에 대한 쓰기 작업을 대기한다.
3.  설정한 `LOCK_TIMEOUT` 내에 `commit` , `rollback` 이 일어나면 대기중이던 세션이 락을 가져와 쓰기 작업을 진행한다.


### DB 락 - 조회 락

---

여담이지만 나는 실무에서 주로 `mssql` 을 사용한다. `mssql` 은  `READ COMMITTED` 격리 수준을 기본 값으로 한다. 이에 더해 흥미로운 점은 `SELECT` 절에서 공유 락(`Shared Lock`)이 걸린다. 물론 `SELECT` 명령이 끝나면 공유락이 해제된다. 그래서 꽤나 긴 시간이 걸릴 것으로 예상하는 쿼리에서는 `with(nolock)` 을 함께 사용하기도 한다.  더 자세한 내용은 [여기](https://learn.microsoft.com/ko-kr/sql/relational-databases/sql-server-transaction-locking-and-row-versioning-guide?view=sql-server-ver16)를 참고하길 바란다.

갑자기 궁금증이 생겨서 내일 출근해서 해봐야겠다. auto commit 모드를 꺼두고 `SELECT` 을 하면 공유 락이 해제되지 않을 것 같다는 생각이??


여튼 일반적으로는 조회 시 락이 걸리지 않는다. 하지만 필요할 때가 있다. 예를 들어 배치 작업처럼 꽤나 긴 시간이 필요한 조회, 생성, 수정 쿼리가 날라가는 작업이라고 해보자. 이 작업이 처리되는 시간동안 해당 레코드에 lock 을 걸어야 할 수도 있다.

조회 시에도 LOCK이 필요하다는 개념 정도만 알고 가면 된다. 

락에는 두 종류가 있다.

베타 락 : 세션1에서 베타 락을 걸면 다른 세션에서는 쓰기/읽기 작업을 하기 위해서는 세션1이 베타 락을 반환할 때 까지 **대기**한다.

공유 락 :  세션1에서 공유 락을 걸면 다른 세션에서는 쓰기 작업을 하기 위해서는 세션1이 공유 락을 반환할 떄 까지 **대기**한다. 하지만 읽기 작업의 경우에는 공유 락을 반환할 때 까지 기다릴 필요가 없다.

*베타 락 획득*

```
SELECT ~ FOR UPDATE
```

*공유 락 획득*

```
SELECT FOR SHARE
```

