
배열은 가장 마지막 인덱스에 데이터를 추가하는 경우`시간 복잡도 O(1)`를 제외하고 기존 데이터의위치를 이동시켜야 한다. 그래서 `시간복잡도 O(n)`을 가진다.

예를 들어 아래와 같은 배열이 있다고 할때 인덱스 0에 5를 추가해보자.
```java
int[] arr = new int[4]
//... 데이터 추가

// | 1 | 2 | 3 | 4 |
```

1. 먼저 배열의 크기가 4라면 배열의 공간을 늘려야 한다. 
2. 이후 오른쪽부터 값을 복사해서 위치를 이동시켜야 한다.

```
1. 공간을 추가 할당한다.
| 1 | 2 | 3 | 4 | 0 | 

2.1 이후 값을 복사해서 넘긴다. 인덱스 3의 4를 복사해 인덱스 4에 할당한다.
| 1 | 2 | 3 | 4 | 4 | 

2.2 인덱스 2의 3을 복사해 인덱스 3에 할당한다.
| 1 | 2 | 3 | 3 | 4 | 

이 과정을 반복하고 마지막에 5를 인덱스 0에 할당한다.
| 5 | 1 | 2 | 3 | 4 |
```


정리하면 이렇다.

- 배열은 크기가 정적이다. 그래서 데이터를 추가하기 위해 배열의 크기를 늘릴 필요가 있다. 그렇다고 처음에 너무 많은 크기를 할당하면 메모리가 비효율적으로 사용될 수 있다.
- 배열에서 데이터 검색, 추가는 `시간복잡도 O(n)`을 가진다.
