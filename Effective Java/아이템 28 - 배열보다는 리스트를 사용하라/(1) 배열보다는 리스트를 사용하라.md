
### 배열과 제네릭 타입의 차이 1

1. 배열은 공변(함께 변한다)이다.
2. 제네릭은 불공변이다.


공변이란, A가 B의 하위 타입일 때 `T <A>` 가 `T <B>` 의 하위 타입이면 공변이다.
불공변이란 A가 B의 하위 타입일 때 `T <A>` 가 `T <B>` 의 하위 타입이 아니면 불공변이다. 이로 인해서 아래와 같은 차이가 존재한다.



```
Object[] objectArr = new Long[1];  // 문제가 없다.
objectArr[0] = "타입이 달라 넣을 수 없다.";

List<Object> objects = new ArrayList<Long>();  // 컴파일 에러
objects.add("타입이 달라 넣을 수 없다.");

```

 배열의 경우에는 공변이기 때문에 `Object[] objectArr = new Long[1]` 선언을 해도 문제가 없다. 실제 배열에 값이 들어갈 때 **런타임 에러**가 발생하게 된다. 반면, 제네릭을 이용하면 불공변이기 때문에 리스트 선언 시 **컴파일 에러**가 발생하게 된다.


### 배열과 제네릭 타입의 차이 2


배열은 실체화 된다.

배열은 **런타임**에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 그래서 우리가 `String[] words = new String[]`  선언한 후 `String` 타입이 아닌 원소를 넣으려고 하면 `ArrayStoreException` 예외가 발생하게 된다.


반면 제네릭은 타입 정보가 **런타임에는 소거**된다. 원소 타입 `List<T>` 의 `T` 를 컴파일 타임에만 검사하며 런타임에는 알 수 없다는 뜻이다.





추가적인 내용이 있지만 지금 다루기에는 조금 내용이 어려워 생략하겠습니다.