
lang 패키지는 자바프로그래밍에 가장 기본이 되는 클래스들을 포함하고 있다. 그렇기 떄문에 java.lang 패키지의 클래스들은 import문 없이도 사용할 수 있게 되어 있다.


## Object 클래스

Object클래슨는 모든 클래스의 최고 조상이다. 따라서 Object 클래스의 멤버들은 모든 클래스에서 바로 사용 가능하다. Object 클래스는 멤버변수가 없다. 오직 11개의 메서드만 가지고 있다.


### equals()

```
public boolean equals(Object obj) {  
    return (this == obj);  
}
```


equals 는 기본적으로 `==` 비교를 한다. 이 의미는 참조 변수의 값을 비교한다는 말이다.

```
Integer num1 = new Integer(1);
Integer num2 = new Integer(1);

num1 == num2 // false
```

즉 위처럼 new 연산자를 통해 1이라는 값을 새롭게 생성된 인스턴스를 각각 참조하고 있는 num1, num2 라 할지라도 == 비교를 하면 서로 참조하고 있는 주소 값이 다르기 때문에 false 값을 가지게 된다.

equals 는 기본적으로 이렇게 정의되어 있다. 일반적으로 이러한 용도로 사용하지는 않는다. String, Integer, LocalDate 와 같은 wrapper 클래스가 equals 메서드를 재정의해서 주소 값이 아닌 내용을 비교하도록 하고 있다. 

사실 이걸 공부할 당시에는 시각이 좁아서 깨우치지 못한게 있었다. 우리가 웹 개발을 할 때 엔티티를 많이 만든다. 쇼핑몰을 예로 든다면 Order, OrderItem, Product 등과 같은 클래스가 만들어질 수 있다. 이렇게 우리가 자체적으로 정의한 클래스는 모두 Object 클래스를 상속하고 있다.

그리고 이들의 equals 는 재정의된 상태가 아니기 때문에 == 비교와 역할이 동일하다. 그러나 우리가 웹 개발을 할 때, 종종 주소 값이 아닌 내용, 쉽게 말해 멤버 변수가 동일한지를 비교해야 하는 경우가 있다. 이런 경우에는 꼭 equals 를 재정의 해야 한다.

마지막으로 equals 를 재정하의하면 hashcode 도 재정의하는 것이 좋다.


### hashCode()

이 메서드는 해싱기법에 사용되는 '해시함수'를 구현한 것이다. 해싱은 데이터 관리 기법 중의 하나이다. 다량의 데이터를 저장하고 검색하는 데 유용하다.

해시함수는 찾고자하는 값을 입력하면, 그 값이 저장된 위치를 알려주는 해시코드를 반환한다.

Object 클래스에 정의된 hashCode 메서드는 객체의 주소값으로 해시코드를 만들어 반환하기 떄문에 32 bit JVM에서는 서로 다른 두 객체는 결코 같은 해시코드를 가질 수 없었지만, 64 bit JVM에서는 8 byte 주소값으로 (4 byte)해시코드를 만들기 떄문에 해시코드가 중복될 수 있다.

정리하면 이렇다. 
```
32bit JVM에서는 4바이트 주소 값 -> 4바이트 해시코드로 변환 중복 X
64bit JVM에서는 8바이트 주소 값 -> 4바이트 해시코드 변환 중복 가능성 O
```


한편, 클래스의 인스턴스변수 값으로 객체의 같고 다름을 판단해야 하는 경우 equals / hashCode 메서드를 둘 다 적절히 오버라이딩해야 한다.

같은 객체라면 hashCode 메서드를 호출했을 떄의 결과값인 해시코드도 같아야 하기 때문이다.

```
참고 : 해싱기법을 사용하는 HashMap이나 HashSet과 같은 클래스에 저장할 객체라면 반드시 hashCode메서드를 오버라이딩해야 한다.
```


String 클래스는 문자열의 내용이 같으면, 동일한 해시코드를 반환하도록 hashCode 메서드가 오버라이딩 되어 있다. 

반면 `System.identityHashCode` 는 Object 클래스 hashCode 메서드처럼 객체의 주소값으로 해시코드를 생성하기 때문에 모든 객체에 대해 항상 다른 해시코드 값을 반환할 것을 보장한다.


### toString()

인스턴스에 대한 정보를 문자열(String)로 제공할 목적으로 정의한 것이다.


```
public String toString() {  
    return getClass().getName() + "@" + Integer.toHexString(hashCode());  
}
```


만약 toString() 매서드를 재정의하지 않았다면, 위 같은 내용이 그대로 사용된다. 즉 클래스 이름에 16진수의 해시코드를 얻게 된다.

```
참고 : 조상에 정의된 메서드를 자손에서 오버라이딩할 때는 조상에 정의된 접근범위보다 같거나 더 넓어야 한다.
```


### clone()

이 메서드는 자신을 복제하여 새로운 인스턴스를 생성하는 일을 한다. 우선 이 메서드를 사용하려면 `Cloneable` 인터페이스를 구현해야 한다.

이 메서드의 존재 이유는 다음과 같다.

```
int[] nums = new int[]{1,2};  
int[] cloneNums = nums;  
int[] cloneNums2 = nums.clone();  
cloneNums[1] = 10000;  
  
System.out.println(nums[0] + " " + nums[1]);  // 1 10000
System.out.println(cloneNums[0] + " " + cloneNums[1]);  // 1 10000
System.out.println(cloneNums2[0] + " " + cloneNums2[1]); // 1 2
```


cloneNums 참조 변수가 nums 를 바라보게 하면 참조 주소 값을 가지게 된다. 이에 따라 cloneNums 배열 내 값을 변경하면 원본에도 영향을 미치게 된다. 이것을 얕은 복사라고 한다.

clone() 메서드는 인스턴스의 값만 복사하기 때문에 이러한 문제를 방지할 수 있다. 값만 복사하는 것을 깊은 복사라고 한다.

정리하면 이렇다. 얕은 복사는 **참조 값**을 복사한다. 따라서 상태(멤버 변수)를 수정할 경우 원본에 영향을 미친다. 반면, 깊은 복사는 **객체의 값(객체의 멤버 변수의 값)** 을 복사한다. 따라서 상태를 수정하더라도 원본에 영향이 가지 않는다.





