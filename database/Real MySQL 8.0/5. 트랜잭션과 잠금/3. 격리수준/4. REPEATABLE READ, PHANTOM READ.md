MySQL InnoDB 스토리지 엔진의 기본 격리 수준이다. 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ 격리 수준 이상을 사용해야 한다. 이 수준에서는 `NON-REPEATABLE READ` 부정합이 발생하지 않는다.

`NON-REPEATABLE READ` 가 발생하지 않는 이유는 트랜잭션 ID와 관련이 있다. 이 트랜잭션 ID는 순차적으로 증가하는 시퀀셜한 ID이고 트랜잭션이 시작될 때 부여된다.

트랜잭션을 시작하고 `SELECT` 명령을 내려 레코드 한 줄을 조회하고 트랜잭션ID 를 11로 부여받았다고 하자. 이후 발생한 다른 트랜잭션에서 트랜잭션 ID는 11보다 큰 값을 할당 받게 된다. 

현재 트랜잭션에서는 트랜잭션ID 11이하에서 발생한 변경 작업만 조회가 가능하다. 다른 트랜잭션에서 변경 작업이 발생하더라도 현재 트랜잭션에서는 트랜잭션ID 11이하의 언두 로그에 저장된 변경 전 데이터만 조회되는 것이다.

이러한 이유로 `NON-REPEATABLE READ` , 이후 설명할  `PHANTOM READ` 도 발생하지 않는다.



트랜잭션 시간이 길어지고 다른 트랜잭션에서 변경 작업이 지속적으로 일어나면 언두 영역이 백업된 데이터로 무한정 커질 수도 있다. 이렇게 되면 MySQL 처리 성능이 떨어질 수 있다.

##### PHANTOM READ
---
`PHANTOM READ` 는 `NON-REPEATABLE READ` 현상과 유사하다 다만 `INSERT` , `DELETE` 에 초점을 둔다. 다시 말해 다른 트랜잭션에서 `INSERT` , `DELETE` 작업이 완료되면 현재 트랜잭션 내에서 조회 결과가 달라진다. 

다만 `INNO DB` 에서는 언두 로그로 인해 `PHANTOM READ`가 발생하지 않는다. 해당 부정합을 보려면 `MySQL` 에서는 `SELECT ~ FOR UPDATE` 구문을 사용하면 된다. 해당 구문은 `SELECT` 레코드에 쓰기 잠금을 거는데 언두 레코드에는 잠금을 걸 수 없기에 테이블 레코드를 가져온다. 그래서  `PHANTOM READ` 현상을 볼 수 있다. 