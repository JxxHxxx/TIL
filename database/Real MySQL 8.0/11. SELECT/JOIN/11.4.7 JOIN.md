
JOIN이 어떻게 인덱스를 사용하는지에 대해 쿼리 패턴별로 살펴본다. JOIN 유형별로 주의할 사항도 함께 살펴본다.

##### JOIN의 순서와 인덱스
---
인덱스 레인지 스캔은 인덱스를 탐색(`Index Seek`)하는 단계와 인덱스를 스캔(`Index Scan`)하는 과정으로 구분해 볼 수 있다.

일반적으로 인덱스를 이요해서 쿼리하는 작업에서는 가져오는 레코드의 건수가 소량이기 때문에 인덱스 스캔 작업은 부하가 작지만 특정 인덱스 키를 찾는 인덱스 탐색 작업은 상대적으로 부하가 높은 편이다.

드라이빙 테이블, 드리븐 테이블

드라이빙 테이블을 읽을 때는 인덱스 탐색 작업을 단 한 번만 수행, 그 이후에는 스캔만 하면 된다.
하지만 드리븐 테이블에서는 인덱스 탐색 작업과 스캔 작업을 드라이빙 테이블에서 읽은 레코드 건수만큼 반복한다.

드라이빙 테이블과 드리븐 테이블이 1:1로 조인되더라도 드리븐 테이블을 읽는 것이 훨씬 더 큰 부하를 차지한다. 그래서 옵티마이저는 항상 드라이빙 테이블이 아니라 드리븐 테이블을 최적으로 읽을 수 있게 실행 계획을 수립한다.

 다음과 같이 두 테이블을 조인하는 쿼리로 인덱스 탐색, 스캔 작업이 어떻게 이루어지는지 보자.

```
SELECT * FROM employees e, dept_emp de
WHERE e.emp_no = de.emp_no;
```


- 두 칼럼 모두 인덱스가 있는 경우

옵티마이저가 선택하는 방식이 최적, 둘 중 어떤 옵티마이저가 통계 정보에 따라 드라이빙 테이블을 지정한다.

- `employees.emp_no` 에만 인덱스가 있는 경우

이 경우에는 `dept_emp` 테이블이 드리븐 테이블로 선택된다면 `employees` 테이블의 레코드 건수만큼 `dept_emp`테이블을 풀 스캔해야만 조건에 일치하는 레코드를 찾을 수 있다. 그래서 옵티마이저는 항상 `dept_emp` 테이블을 드라이빙 테이블로 선택한다.

이 경우에는 먼저 `employees` 테이블을 읽고 `employees.emp_no`  값에 대해 `dept_emp` 테이블에서 `emp_no` 와 매칭되는 레코드를 찾아와야 한다. 이 과정에서 `dept_emp` 테이블의 `emp_no` 컬럼에 인덱스가 없기 때문에 풀 테이블 스캔이 일어난다.  이러한 비효율을 막기 위해 인덱스가 없는 테이블을 드라이빙 테이블로 지정한다.

즉 조건 컬럼에 인덱스가 없는 테이블을 드라이빙 테이블로 설정하여 인덱스 레인지 스캔을 유도한다.

- `dept_emp.emp_no` 에만 인덱스가 있는 경우

위와 동일하게 인덱스가 없는 테이블인 `employees` 테이블을 드라이빙 테이블로 지정한다.

- 두 컬럼 모두 인덱스가 없는 경우,

이 경우에는 어떤 경우라도 풀 스캔이 발생한다. 그래서 레코드 건수가 적은 테이블이 드라이빙 테이블로 선택하는 것이 효율적이다. `8.0.18` 버전 이후에는 해시 조인으로 처리한다.

