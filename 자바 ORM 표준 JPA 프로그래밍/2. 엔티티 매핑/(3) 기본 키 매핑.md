
지금까지는 `@Id` 애노테이션과 생성자를 통해 기본 키 값을 지정해서 기본 키(`PK`)를 애플리케이션에서 할당했다. 이외에도 JPA가 제공하는 데이터베이스 기본 키 생성 전략은 다음과 같다.


- 직접 할당 : 기본 키를 애플리케이션에서 직접 할당 (우리가 지금까지 한 방식)
- 자동 생성 : 대리 키 사용 방식, `@GeneratedValue` 사용
	-  `IDENTITY` : 기본 키 생성을 데이터베이스에 위임
	-  `SEQUENCE` : 데이터베이스 시퀀스를 사용해서 기본 키 할당
	-  `TABLE` : 키 생성 테이블을 사용


#### 기본 키 직접 할당

`@Id` 적용이 가능한 자바 타입은 다음과 같다.

- `primitive` , `Wrapper` 타입
- `String` , `java.util.Date` , `java.sql.Date`
-  `java.math.BigDecimal` , `java.math.BigInteger`

기본 키를 직접 할당할 때는 `em.persist()` 로 엔티티를 저장하기 **전**에 애플리케이션에서 기본 키를 직접 할당하는 방법이다. 만약 기본 키를 직접 할당할 때 식별자 값이 없으면 하이버네이트 기준 `identifierGenerationException` 예외가 발생한다.


#### IDENTITY 전략

기본 키 생성을 데이터베이스에 위임하는 전략이다. 예를 들어 `MySQL` 을 사용할 경우 `AUTO_INCREMENT` 가  `ID` 컬럼에 추가된다. `H2` 경우 `generated by default as identity` 가 추가되는 것을 볼 수 있다.

`IDENTITY` 전략은 엔티티를 데이터베이스에 저장하고 나서 기본 키 값을 구할 수 있다는 특징이 있다.  아래 코드와 실행 결과를 통해 이 말의 의미를 이해보도록 하자.

```
Product product = new Product("상품1", 0, createProductCode());  

System.out.println("데이터 베이스 반영 전");  
System.out.println("product id = " + product.getId());  

em.persist(product);  

System.out.println("데이터 베이스 반영 후");  
Product findProduct = em.find(Product.class, product.getId());  
System.out.println("findProduct.getId = " + findProduct.getId());
```


*결과*

![[Pasted image 20231015132932.png]](../images/Pasted%20image%2020231015132932.png)


*IDENTITY 전략과 최적화*

생각해보면 `IDENTITY` 전략을 사용하면 기본 키 값을 가져오기 위해서는 데이터베이스와 2번 통신해야 한다. 하지만 `INSERT` 한 번으로 기본 키를 가져온다. 그 해답은 아래 있다.

```
IDENTITY 전략은 데이터를 데이터베이스에 INSERT 한 후에 기본 키 값을 조회할 수 있다. 따라서 엔티티에 식별자 값을 할당하려면 JPA는 추가로 데이터베이스를 조회해야 한다. 즉 쿼리를 INSERT 1번, SELECT 1번 날려야 한다. 하지만 JDBC3에 추가된 Statement.getGeneratedKeys() 를 사용하면 데이터를 저장하면서 동시에 생성된 기본 키 값도 얻어올 수 있다 .이를 통해 하이버네이트는 데이터베이스와 한 번만 통신하여 기본 키를 가져온다.
```


---
#### SEQUENCE 전략

데이터베이스 시퀀스는 유일한 값을 순서대로 생성한는 데이터베이스 오브젝트다. 쉽게 말하면 데이터베이스에 시퀀스 테이블이 생긴다. 이 시퀀스 테이블을 사용해서 기본 키를 생성한다.

우선 테이블과 시퀀스를 만들자.

```
CREATE TABLE BOARD (  
    id BIGINT NOT NULL  PRIMARY KEY,  
    name VARCHAR(255)  
);  
  
CREATE SEQUENCE BOARD_SEQ START WITH 1 INCREMENT BY 1;
```

H2 콘솔을 확인해보면 테이블과 시퀀스가 생성된 것을 볼 수 있다.

![[Pasted image 20231015140049.png]](../images/Pasted%20image%2020231015140049.png)

이후 엔티티 클래스에 `@SequenceGenerator`  , `@GeneratedValue` 를 통해 시퀀스를 매핑하자.

```
@Entity  
@SequenceGenerator(  
        name = "BOARD_SEQ_GENERATOR",  
        sequenceName = "BOARD_SEQ", 
        initialValue = 1, allocationSize = 1  
)  
public class Board {  
  
    @Id @GeneratedValue(strategy = SEQUENCE, generator = "BOARD_SEQ_GENERATOR")  
    private Long id;  
    private String name;  
  
    public Board() {  
    }  
}
```


`SEQUENCE` 전략은 `em.persist()` 를 호출할 때 먼저 데이터베이스 시퀀스를 사용해서 식별자를 조회한다. 그리고 조회한 식별자를 엔티티에 할당한 후에 엔티티를 영속성 컨텍스트에 저장한다. 이후 트랜잭션을 커밋해서 엔티티를 데이터베이스에 저장한다.



*SEQUENCE 전략과 최적화*

해단 전략은 데이터베이스 시퀀스를 통해 식별자를 조회하기 때문에 데이터베이스와 2번 통신한다.
JPA는 시퀀스에 접근하는 횟수를 줄이기 위해 `@SequenceGenerator` 의 `allocationSize`를 사용한다.`allocationSize` 를 설정한 값만큼 한 번에 시퀀스 값을 증가시키고 나서 그만큼 메모리에 시퀀스 값을 할당한다. 

예를 들어 `allocationSize = 50` 이면 시퀀스를 한 번에 50 증가시킨다. 이를 통해 1 ~ 50 까지는 메모리 상에서, 다시 말해 애플리케이션에서 식별자를 할당한다. 그리고 51이 되면 시퀀스 값을 100으로 증가시킨 다음 51 ~ 100까지 메모리에서 식별자를 할당한다.

이 방법은 시퀀스 값을 선점하므로 여러 JVM이 동시에 동작해도 기본 키 값이 충돌하지 않는 장점이 있다. 반면에 데이터베이스에 직접 접근해서 데이터를 등록할 때는 시퀀스 값이 한 번에 많이 증가한다는 점을 염두해두어야 한다.


---
####  IDENTITY s SEQUNECE


- IDENTITY
1. 엔티티를 데이터베이스에 저장한다.
2. 데이터베이스에 저장한 후 식별자를 조회해서 엔티티의 식별자에 할당한다.
3. 영속성 컨텍스트에 해당 엔티티를 저장한다.

- SEQUENCE
1. 데이터베이스에서 시퀀스를 조회한다.
2. 엔티티에 식별자를 할당하고 영속성 컨텍스트에 저장한다.
3. 이후 데이터베이스에 저장한다.




