
앞서 프록시 페이지를 읽어보았다면 즉시 로딩, 지연 로딩이 무엇인지 대략적으로 파악했을 것이다.

실무에서는 지연 로딩을 권장한다. 이유는 다음과 같다.

1. 즉시 로딩은 예상치 못한 성능 하락을 발생시킬 수 있다. (아주 큰)
2. 쿼리를 예측하기 힘들다

사실 1,2번이 연결되는 내용이다. 예상치 못할 정도의 성능 하락이 일어나려면 예측하지도 못 할 만한 쿼리가 나가기 떄문이다.

해결책은 `@XxxToOne` 애노테이션 패치 전략은 `LAZY` 로 설정하는 것이다. 참고로 `@XxxToMany` 는 패치 전략 디폴트가 `LAZY` 다. 

이유가 무엇이냐면 `@XxxToOne` 에서 연관 관계 엔티티를 가져오기 위해 `join` 을 거는데 이게 생각보다 비용이 크지는 않다. `join` 을 여러개 걸더라도 특이한 케이스가 아니라면  `PK`(유니크 클러스터 인덱스) 로 조인을 걸기 때문에 상당히 빠르다.  그럼에도 사용하지 않으면 굳이 조회할 필요가 없다.

다만 더 큰 문제는 `N + 1` 문제이다. `JPQL` 을 사용하면 발생하게 된다.

기본적으로 JPQL은 쿼리로 변환된다. 예를 들어 `SELECT m FROM Member m`  JPQL은 `SELECT * FROM Member`  로 변환된다. 조회해보니 만약 연관된 엔티티의 패치 전략이 `EAGER` 라면 또 다시 그 엔티티를 조회하기 위해 쿼리를 날려야 한다. 이 때 연관된 엔티티의 개수(`N`) 만큼 날리기 때문에 `N + 1` 문제라고 한다.

중요한 부분 중 하나는 지연 로딩을 사용한다고 `N + 1` 문제를 해결할 수 있는건 아니다. 약간의 안전장치를 걸었을 뿐이다. 순수하게 `Memeber` 를 조회할 때 `N + 1` 문제가 발생하지 않도록 하는 것이다.

`N + 1` 문제를 해결하는 방법은 `join fetch` ,  `@EntityGraph` 등이 존재한다.


##### 즉시로딩 지연 로딩 정리
---

**실무에서 지연 로딩을 권장**
이유 : 성능 하락 예방과 복잡한 쿼리 차단

하지만 실무에서는 복잡해질 수 밖에 없는 쿼리들이 존재한다. `ORM` 을 사용하던 `MyBatis` 같은 매퍼 라이브러리를 사용하던 공통적으로 존재한다. 

재밋는건 공통적인 문제이지만  헤이터들이 `ORM` 을 사용하지 않는 이유로 거론하는 것 중 하나이다. 뭐... 맞는 말이긴 하다.

`Mybatis` , `JdbcTemplate` 은 프로젝트 내부에 호출되는 쿼리를 명시하기 때문에 예측할 수 있기 때문이다.

이러한 점을 보완해주는게 지연 로딩이다. 그리고 `ORM` 에서 사실 복잡한 쿼리는 `JPQL` , `QueryDSL` 을 사용하게 된다. `JPQL` 사실 쿼리가 명시되기 때문에 `JPQL` 문법만 조금 안다면 상관없다.

`QueryDSL` 경우에는 기본적으로 동적 쿼리를 사용하기 위함인데 이건 정말로 아무리 잘짜도 쿼리의 명확성 측면에선 `Mybatis` 를 따라갈 수 없다. 근데 이건 `ORM` 이 어쩔 수 없는 특징이다. 

쿼리를 직접 박아 내부에서 `if` 분기를 하는 `MyBatis` 가 당연히 애플리케이션 코드로 짠 `QueryDSL` 코드보다 쿼리 가독성이 좋은건 당연하다. 그래도 우리는 `ORM` 이 주는 장점이 많기 때문에 사용하는 것이니 감내해야 한다.

**지연 로딩은 안전 장치일 뿐 해결책은 아니다.**
앞서 말했겠지만 지연 로딩은 안전 장치이다. 어짜피 대상 엔티티를 호출하면 `N+1` 문제가 발생하게 된다. `join fetch` , `@EntityGraph` 등을 통해 해결해야 한다.








